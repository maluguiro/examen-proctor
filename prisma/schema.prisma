// Prisma schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    String @id @default(cuid())
  email String @unique
  role  String // 'teacher' | 'student'

  // Auth bÃ¡sica + Perfil
  name         String? // nombre visible
  passwordHash String?
  createdAt    DateTime @default(now())

  teacherProfile  TeacherProfile?
  teacherCalendar TeacherCalendar?
  examMembers     ExamMember[]
  examInvitesSent ExamInvite[] @relation("ExamInviteSent")
}

model TeacherProfile {
  id           String @id @default(cuid())
  userId       String @unique
  fullName     String
  // Array de { id, name, kind?, subjects: [{ id, name }] }
  institutions Json

  user      User     @relation(fields: [userId], references: [id])
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model Exam {
  id         String     @id @default(uuid())
  title      String
  status     ExamStatus @default(DRAFT)
  updatedAt  DateTime   @default(now()) @updatedAt
  startsAt   DateTime?
  endsAt     DateTime?
  publicCode String     @unique

  // DuraciÃ³n: seguimos usando estos campos en la DB
  durationMin  Int? // viejo
  durationMins Int? // compatibilidad

  lives         Int       @default(3)
  pausesAllowed Boolean   @default(false)
  forgiveLives  Boolean   @default(false)
  ownerId       String
  createdAt     DateTime  @default(now())
  expiresAt     DateTime?

  // ðŸ”¹ NUEVOS CAMPOS para la meta docente
  teacherName String? // ej: "Prof. GÃ³mez"
  university  String? // ej: "Universidad X" ðŸ‘ˆ NUEVO
  subject     String? // ej: "MatemÃ¡tica I"
  gradingMode String    @default("auto") // 'auto' | 'manual'
  maxScore    Int?
  openAt      DateTime?

  questions Question[]
  attempts  Attempt[]
  members   ExamMember[]
  invites   ExamInvite[]
}

model Question {
  id        String       @id @default(uuid())
  examId    String
  kind      QuestionKind @default(TEXT)
  text      String
  options   Json?
  answerKey Json?

  points       Int      @default(1)
  createdAt    DateTime @default(now()) // <-- agregado
  allowedKinds Json? // p.ej. ["TRUE_FALSE","MCQ"] â€” si null o [], es MIXTO (todas)

  exam Exam @relation(fields: [examId], references: [id])
}

model Attempt {
  id            String    @id @default(cuid())
  examId        String
  studentId     String
  studentName   String?
  status        String    @default("in_progress") // in_progress | submitted
  startAt       DateTime  @default(now())
  endAt         DateTime?
  score         Float?
  livesUsed     Int       @default(0)
  paused        Boolean   @default(false)
  extraTimeSecs Int       @default(0)
  questionOrder Json? // orden de preguntas por alumno

  exam     Exam      @relation(fields: [examId], references: [id])
  events   Event[]
  answers  Answer[]
  messages Message[]
}

model Answer {
  id          String   @id @default(cuid())
  attemptId   String
  questionId  String
  content     Json? // mcq: ["a","c"], tf: true/false, text: string
  isCorrect   Boolean?
  score       Float?
  timeSpentMs Int      @default(0)

  attempt Attempt @relation(fields: [attemptId], references: [id])

  @@unique([attemptId, questionId])
}

enum ExamRole {
  OWNER
  GRADER
  PROCTOR
}

model ExamMember {
  id        String   @id @default(cuid())
  examId    String
  userId    String
  role      ExamRole
  createdAt DateTime @default(now())

  exam Exam @relation(fields: [examId], references: [id])
  user User @relation(fields: [userId], references: [id])

  @@unique([examId, userId])
}

model ExamInvite {
  id               String    @id @default(cuid())
  examId           String
  email            String
  role             ExamRole  @default(GRADER)
  tokenHash        String
  expiresAt        DateTime
  acceptedAt       DateTime?
  invitedByUserId  String
  createdAt        DateTime  @default(now())

  exam       Exam @relation(fields: [examId], references: [id])
  invitedBy  User @relation("ExamInviteSent", fields: [invitedByUserId], references: [id])

  @@index([examId])
  @@index([email])
}

model Event {
  id        String   @id @default(cuid())
  attemptId String
  type      String
  reason    String?
  ts        DateTime @default(now())
  meta      Json?

  attempt Attempt @relation(fields: [attemptId], references: [id])
}

model Message {
  id        String   @id @default(cuid())
  attemptId String
  from      String // 'student' | 'teacher'
  text      String
  ts        DateTime @default(now())

  attempt Attempt @relation(fields: [attemptId], references: [id])
}

// -----------------------------
// ENUMS FALTANTES
// -----------------------------

enum ExamStatus {
  DRAFT  @map("draft")
  OPEN   @map("open")
  CLOSED @map("closed")
}

enum QuestionKind {
  MULTIPLE_CHOICE @map("multiple_choice")
  TRUE_FALSE      @map("true_false")
  TEXT            @map("text")
  FILL_GAPS       @map("fill_gaps")
}

model PasswordResetToken {
  id        String   @id @default(uuid())
  token     String   @unique
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model TeacherCalendar {
  id        String @id @default(cuid())
  teacherId String @unique

  events Json @default("[]")
  tasks  Json @default("[]")

  updatedAt DateTime @updatedAt

  teacher User @relation(fields: [teacherId], references: [id], onDelete: Cascade)
}
